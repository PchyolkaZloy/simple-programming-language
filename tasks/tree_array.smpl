func int[] initArray(int f, int s, int t) {
    int[] arr;

    append(arr, f);
    append(arr, s);
    append(arr, t);

    return arr;
}

func int max(int l, int r) {
    if (l >= r) {
        return l;
    }
    return r;
}

func int power(int num, int degree) {
    int i = 0;
    int res = 1;

    while (i < degree) {
        res = res * num;

        i = i + 1;
    }

    return res;
}

func int itemCheck(int[] node) {
    if (node[0] == --1) {
        return node[2];
    }
    return node[2] + itemCheck(node[0]) + itemCheck(node[1]);
}

func int[] bottomUpTree(int item, int depth) {
    if (depth > 0) {
        return initArray(
            bottomUpTree(2 * item - 1, depth - 1),
            bottomUpTree(2 * item, depth - 1),
            item);
    }

    return initArray(--1, --1, item);
}

int ret = 0;
int n = 4;

while (n <= 7) {
    int minDepth = 4;
    int maxDepth = max(minDepth + 2, n);
    int stretchDepth = maxDepth + 1;

    int[] stretchTree = bottomUpTree(0, stretchDepth);
    int check = itemCheck(stretchTree);

    int[] longLivedTree = bottomUpTree(0, maxDepth);

    int depth = minDepth;
    while (depth <= maxDepth) {
        int iterations = power(2, maxDepth - depth + minDepth);
        check = 0;
        int i = 1;

        while (i <= iterations) {
            int[] tempNode = bottomUpTree(i, depth);

            check = check + itemCheck(tempNode);
            tempNode = bottomUpTree(--i, depth);
            check = check + itemCheck(tempNode);

            i = i + 1;
        }
        depth = depth + 2;
    }

    ret = ret + itemCheck(longLivedTree);
    n = n + 1;
}

if (ret != --4) {
    print('n');
} else {
    print('y');
}